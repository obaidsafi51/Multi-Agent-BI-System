"""
Enhanced NLP Agent WebSocket Server v2.2.0
WebSocket server that runs alongside the HTTP server for real-time communication
"""

import asyncio
import json
import     async def process_request(self, path, request_headers):
        """Process request before WebSocket handling to check path"""
        # Accept any path, but log for debugging
        logger.debug(f"WebSocket connection attempt on path: {path}")
        return None  # Continue with WebSocket connection
        
    async def handle_connection(self, websocket: WebSocketServerProtocol, path: str = "/"):
        """Handle new WebSocket connection"""
        client_id = f"nlp-client-{uuid.uuid4().hex[:8]}"
        logger.info(f"New WebSocket connection from {websocket.remote_address} on path {path} (ID: {client_id})")
        
        # Add to active connections
        self.connections.add(websocket)
        self.connection_count += 1import os
import time
import uuid
from datetime import datetime
from typing import Dict, Any, Optional, Set
import websockets
import websockets.exceptions
from websockets.server import WebSocketServerProtocol

from src.optimized_nlp_agent import OptimizedNLPAgent
from src.enhanced_websocket_client import EnhancedWebSocketMCPClient
from src.performance_optimizer import PerformanceOptimizer
from src.enhanced_monitoring import EnhancedMonitoringSystem
from src.query_classifier import QueryClassifier
from performance_config import PerformanceConfig

# Import standardized models
from shared.models.workflow import NLPResponse, QueryIntent, AgentMetadata, ErrorResponse

logger = logging.getLogger(__name__)


class WebSocketNLPServer:
    """WebSocket server for NLP agent with connection management and message handling"""
    
    def __init__(self, host: str = "0.0.0.0", port: int = 8011):
        self.host = host
        self.port = port
        self.server = None
        self.connections: Set[WebSocketServerProtocol] = set()
        
        # Agent components (will be initialized)
        self.nlp_agent: Optional[OptimizedNLPAgent] = None
        self.websocket_client: Optional[EnhancedWebSocketMCPClient] = None
        self.query_classifier: Optional[QueryClassifier] = None
        self.performance_optimizer: Optional[PerformanceOptimizer] = None
        self.monitoring_system: Optional[EnhancedMonitoringSystem] = None
        
        # Statistics
        self.start_time = time.time()
        self.message_count = 0
        self.connection_count = 0
    
    async def initialize_agent(self):
        """Initialize the NLP agent and its components"""
        try:
            logger.info("Initializing Enhanced NLP Agent components for WebSocket server...")
            
            # Initialize monitoring system first
            async def alert_handler(alert):
                logger.error(f"ALERT [{alert.level.value.upper()}]: {alert.message}")
            
            self.monitoring_system = EnhancedMonitoringSystem(
                metrics_retention_hours=24,
                snapshot_interval_seconds=30,
                alert_handlers=[alert_handler]
            )
            await self.monitoring_system.start()
            
            # Get performance configuration
            environment = os.getenv("ENVIRONMENT", "development")
            perf_config = PerformanceConfig.get_config(environment)
            logger.info(f"Using performance configuration for: {environment}")
            
            # Initialize performance optimizer
            optimizer_config = perf_config["optimizer"]
            self.performance_optimizer = PerformanceOptimizer(
                memory_cache_size=optimizer_config["memory_cache_size"],
                semantic_cache_size=optimizer_config["semantic_cache_size"],
                query_cache_size=optimizer_config["query_cache_size"],
                schema_cache_ttl=optimizer_config["schema_cache_ttl"],
                context_cache_ttl=optimizer_config["context_cache_ttl"],
                semantic_similarity_threshold=optimizer_config["semantic_similarity_threshold"],
                enable_request_deduplication=optimizer_config["enable_request_deduplication"],
                enable_response_prediction=optimizer_config["enable_response_prediction"]
            )
            self.performance_optimizer.start()
            
            # Initialize WebSocket MCP client
            self.websocket_client = EnhancedWebSocketMCPClient(
                ws_url="ws://tidb-mcp-server:8000/ws",
                max_reconnect_attempts=5,
                heartbeat_interval=30
            )
            await self.websocket_client.connect()
            
            # Initialize query classifier
            self.query_classifier = QueryClassifier()
            
            # Initialize main NLP agent with proper parameters
            kimi_api_key = os.getenv("KIMI_API_KEY")
            mcp_server_url = os.getenv("MCP_SERVER_URL", "ws://tidb-mcp-server:8000/ws")
            
            self.nlp_agent = OptimizedNLPAgent(
                kimi_api_key=kimi_api_key,
                mcp_ws_url=mcp_server_url,
                agent_id="nlp-agent-websocket-001",
                enable_optimizations=True,
                enable_semantic_caching=True,
                enable_request_batching=True
            )
            await self.nlp_agent.start()
            
            logger.info("Enhanced NLP Agent components initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize NLP agent: {e}")
            raise
    
    async def start_server(self):
        """Start the WebSocket server"""
        try:
            await self.initialize_agent()
            
            logger.info(f"Starting NLP WebSocket server on {self.host}:{self.port}")
            
            self.server = await websockets.serve(
                self.handle_connection,
                self.host,
                self.port,
                ping_interval=30,
                ping_timeout=10,
                close_timeout=5,
                process_request=self.process_request
            )
            
            logger.info(f"NLP WebSocket server started on ws://{self.host}:{self.port}")
            
        except Exception as e:
            logger.error(f"Failed to start WebSocket server: {e}")
            raise
    
    async def stop_server(self):
        """Stop the WebSocket server"""
        logger.info("Stopping NLP WebSocket server...")
        
        if self.server:
            self.server.close()
            await self.server.wait_closed()
        
        # Close all connections
        if self.connections:
            await asyncio.gather(
                *[conn.close() for conn in self.connections],
                return_exceptions=True
            )
        
        # Cleanup agent components
        if self.nlp_agent:
            await self.nlp_agent.cleanup()
        
        if self.websocket_client:
            await self.websocket_client.disconnect()
        
        if self.monitoring_system:
            await self.monitoring_system.stop()
        
        logger.info("NLP WebSocket server stopped")
    
    async def handle_connection(self, websocket: WebSocketServerProtocol, path: str = "/"):
        """Handle new WebSocket connection"""
        client_id = f"nlp-client-{uuid.uuid4().hex[:8]}"
        logger.info(f"New WebSocket connection from {websocket.remote_address} on path {path} (ID: {client_id})")
        
        # Add to active connections
        self.connections.add(websocket)
        self.connection_count += 1
        
        try:
            # Send welcome message
            welcome_message = {
                "type": "connection_established",
                "server": "nlp-agent-websocket",
                "version": "2.2.0",
                "client_id": client_id,
                "timestamp": datetime.utcnow().isoformat(),
                "capabilities": [
                    "nlp_query",
                    "health_check", 
                    "real_time_processing",
                    "optimized_performance"
                ]
            }
            await websocket.send(json.dumps(welcome_message))
            
            # Handle messages from this connection
            async for message in websocket:
                try:
                    if isinstance(message, str):
                        data = json.loads(message)
                        await self.handle_message(websocket, data, client_id)
                    self.message_count += 1
                    
                except json.JSONDecodeError:
                    await self.send_error(websocket, "Invalid JSON message", client_id)
                except Exception as e:
                    logger.error(f"Error handling message from {client_id}: {e}")
                    await self.send_error(websocket, str(e), client_id)
                    
        except websockets.exceptions.ConnectionClosed:
            logger.info(f"WebSocket connection closed for client {client_id}")
        except Exception as e:
            logger.error(f"Error in WebSocket connection {client_id}: {e}")
        finally:
            # Remove from active connections
            self.connections.discard(websocket)
    
    async def handle_message(self, websocket: WebSocketServerProtocol, data: Dict, client_id: str):
        """Handle incoming WebSocket message"""
        try:
            message_type = data.get("type", "unknown")
            message_id = data.get("message_id", str(uuid.uuid4()))
            
            logger.debug(f"Handling message type '{message_type}' from client {client_id}")
            self.message_count += 1
            
            # Route message based on type
            if message_type == "heartbeat":
                await self.handle_heartbeat(websocket, data, client_id)
            elif message_type == "nlp_query":
                await self.handle_nlp_query(websocket, data, client_id, message_id)
            elif message_type == "health_check":
                await self.handle_health_check(websocket, data, client_id, message_id)
            elif message_type == "stats":
                await self.handle_stats_request(websocket, data, client_id, message_id)
            else:
                await self.send_error(websocket, f"Unknown message type: {message_type}", client_id)
                
        except Exception as e:
            logger.error(f"Error handling message from {client_id}: {e}")
            await self.send_error(websocket, str(e), client_id)
    
    async def handle_heartbeat(self, websocket: WebSocketServerProtocol, data: Dict, client_id: str):
        """Handle heartbeat message"""
        response = {
            "type": "heartbeat_response",
            "timestamp": datetime.utcnow().isoformat(),
            "server_time": time.time(),
            "client_id": client_id,
            "correlation_id": data.get("correlation_id")
        }
        await websocket.send(json.dumps(response))
    
    async def handle_health_check(self, websocket: WebSocketServerProtocol, data: Dict, client_id: str, message_id: str):
        """Handle health check request"""
        uptime = time.time() - self.start_time
        
        health_data = {
            "status": "healthy",
            "uptime": uptime,
            "connections": len(self.connections),
            "messages_processed": self.message_count,
            "version": "2.2.0",
            "agent_ready": self.nlp_agent is not None
        }
        
        response = {
            "type": "health_check_response",
            "response_to": message_id,
            "client_id": client_id,
            "timestamp": datetime.utcnow().isoformat(),
            "data": health_data
        }
        
        await websocket.send(json.dumps(response))
    
    async def handle_nlp_query(self, websocket: WebSocketServerProtocol, data: Dict, client_id: str, message_id: str):
        """Handle NLP query request"""
        try:
            if not self.nlp_agent:
                raise RuntimeError("NLP agent not initialized")
            
            query = data.get("query", "")
            context = data.get("context", {})
            query_id = data.get("query_id", str(uuid.uuid4()))
            
            if not query:
                raise ValueError("Query is required")
            
            logger.info(f"Processing NLP query from client {client_id}: '{query[:50]}...'")
            
            # Send processing started message
            await self.send_progress(websocket, message_id, client_id, "processing_started", 10)
            
            # Process the query using the optimized NLP agent
            start_time = time.time()
            
            result = await self.nlp_agent.process_query_optimized(
                query=query,
                context=context
            )
            
            processing_time = time.time() - start_time
            
            # Send processing completed message
            await self.send_progress(websocket, message_id, client_id, "processing_completed", 100)
            
            # Prepare response
            response = {
                "type": "nlp_query_response",
                "response_to": message_id,
                "client_id": client_id,
                "query_id": query_id,
                "timestamp": datetime.utcnow().isoformat(),
                "processing_time": processing_time,
                "success": True,
                "data": result
            }
            
            await websocket.send(json.dumps(response))
            logger.info(f"NLP query processed successfully for client {client_id} in {processing_time:.2f}s")
            
        except Exception as e:
            logger.error(f"Error processing NLP query for client {client_id}: {e}")
            
            error_response = {
                "type": "nlp_query_response",
                "response_to": message_id,
                "client_id": client_id,
                "timestamp": datetime.utcnow().isoformat(),
                "success": False,
                "error": {
                    "type": "nlp_processing_error",
                    "message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                }
            }
            
            await websocket.send(json.dumps(error_response))
    
    async def handle_stats_request(self, websocket: WebSocketServerProtocol, data: Dict, client_id: str, message_id: str):
        """Handle statistics request"""
        stats = self.get_stats()
        
        response = {
            "type": "stats_response",
            "response_to": message_id,
            "client_id": client_id,
            "timestamp": datetime.utcnow().isoformat(),
            "data": stats
        }
        
        await websocket.send(json.dumps(response))
    
    async def send_progress(self, websocket: WebSocketServerProtocol, message_id: str, client_id: str, status: str, progress: int):
        """Send progress update"""
        progress_message = {
            "type": "progress_update",
            "response_to": message_id,
            "client_id": client_id,
            "timestamp": datetime.utcnow().isoformat(),
            "status": status,
            "progress": progress
        }
        
        try:
            await websocket.send(json.dumps(progress_message))
        except Exception as e:
            logger.warning(f"Failed to send progress update to client {client_id}: {e}")
    
    async def send_error(self, websocket: WebSocketServerProtocol, error_message: str, client_id: str):
        """Send error message to client"""
        error_response = {
            "type": "error",
            "client_id": client_id,
            "timestamp": datetime.utcnow().isoformat(),
            "error": {
                "message": error_message,
                "type": "server_error"
            }
        }
        
        try:
            await websocket.send(json.dumps(error_response))
        except Exception as e:
            logger.error(f"Failed to send error message to client {client_id}: {e}")
    
    async def broadcast_message(self, message: Dict):
        """Broadcast message to all connected clients"""
        if not self.connections:
            return
        
        message_json = json.dumps(message)
        
        # Send to all connected clients
        await asyncio.gather(
            *[conn.send(message_json) for conn in self.connections],
            return_exceptions=True
        )
    
    def get_stats(self) -> Dict[str, Any]:
        """Get server statistics"""
        uptime = time.time() - self.start_time
        
        return {
            "server": "nlp-agent-websocket",
            "version": "2.2.0",
            "uptime": uptime,
            "connections": len(self.connections),
            "total_connections": self.connection_count,
            "messages_processed": self.message_count,
            "agent_initialized": self.nlp_agent is not None,
            "status": "running" if self.server else "stopped"
        }


# Global server instance
websocket_server: Optional[WebSocketNLPServer] = None


async def start_websocket_server():
    """Start the WebSocket server"""
    global websocket_server
    
    host = os.getenv("WEBSOCKET_HOST", "0.0.0.0")
    port = int(os.getenv("WEBSOCKET_PORT", "8011"))
    
    websocket_server = WebSocketNLPServer(host=host, port=port)
    await websocket_server.start_server()
    
    return websocket_server


async def stop_websocket_server():
    """Stop the WebSocket server"""
    global websocket_server
    
    if websocket_server:
        await websocket_server.stop_server()
        websocket_server = None


if __name__ == "__main__":
    import sys
    
    async def main():
        """Main function to run the WebSocket server"""
        try:
            server = await start_websocket_server()
            logger.info("NLP WebSocket server is running. Press Ctrl+C to stop.")
            
            # Keep server running
            try:
                await asyncio.Event().wait()
            except KeyboardInterrupt:
                logger.info("Received interrupt signal")
            finally:
                await stop_websocket_server()
                
        except Exception as e:
            logger.error(f"Failed to start server: {e}")
            sys.exit(1)
    
    # Run the server
    asyncio.run(main())
